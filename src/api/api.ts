/* tslint:disable */
/* eslint-disable */
/**
 * USJ Matching App API
 * USJでの出会いとマッチングを支援するアプリケーションのAPI
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@usj-matching.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Attraction
 */
export interface Attraction {
    /**
     * 
     * @type {number}
     * @memberof Attraction
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Attraction
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attraction
     */
    'category'?: AttractionCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof Attraction
     */
    'area'?: AttractionAreaEnum;
    /**
     * 
     * @type {string}
     * @memberof Attraction
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attraction
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof Attraction
     */
    'averageWaitTime'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Attraction
     */
    'isOperating'?: boolean;
}

export const AttractionCategoryEnum = {
    Ride: 'RIDE',
    Show: 'SHOW',
    Restaurant: 'RESTAURANT',
    Shop: 'SHOP',
    Other: 'OTHER'
} as const;

export type AttractionCategoryEnum = typeof AttractionCategoryEnum[keyof typeof AttractionCategoryEnum];
export const AttractionAreaEnum = {
    Hollywood: 'HOLLYWOOD',
    NewYork: 'NEW_YORK',
    SanFrancisco: 'SAN_FRANCISCO',
    JurassicPark: 'JURASSIC_PARK',
    AmityVillage: 'AMITY_VILLAGE',
    Waterworld: 'WATERWORLD',
    WizardingWorld: 'WIZARDING_WORLD',
    MinionPark: 'MINION_PARK',
    Other: 'OTHER'
} as const;

export type AttractionAreaEnum = typeof AttractionAreaEnum[keyof typeof AttractionAreaEnum];

/**
 * 
 * @export
 * @interface AttractionDetail
 */
export interface AttractionDetail {
    /**
     * 
     * @type {number}
     * @memberof AttractionDetail
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AttractionDetail
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttractionDetail
     */
    'category'?: AttractionDetailCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof AttractionDetail
     */
    'area'?: AttractionDetailAreaEnum;
    /**
     * 
     * @type {string}
     * @memberof AttractionDetail
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttractionDetail
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof AttractionDetail
     */
    'averageWaitTime'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AttractionDetail
     */
    'isOperating'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AttractionDetail
     */
    'detailedDescription'?: string;
    /**
     * 
     * @type {number}
     * @memberof AttractionDetail
     */
    'heightRestriction'?: number;
    /**
     * 
     * @type {number}
     * @memberof AttractionDetail
     */
    'duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof AttractionDetail
     */
    'capacity'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AttractionDetail
     */
    'fastPassAvailable'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof AttractionDetail
     */
    'accessibility'?: Array<string>;
    /**
     * 
     * @type {AttractionDetailAllOfOperatingHours}
     * @memberof AttractionDetail
     */
    'operatingHours'?: AttractionDetailAllOfOperatingHours;
}

export const AttractionDetailCategoryEnum = {
    Ride: 'RIDE',
    Show: 'SHOW',
    Restaurant: 'RESTAURANT',
    Shop: 'SHOP',
    Other: 'OTHER'
} as const;

export type AttractionDetailCategoryEnum = typeof AttractionDetailCategoryEnum[keyof typeof AttractionDetailCategoryEnum];
export const AttractionDetailAreaEnum = {
    Hollywood: 'HOLLYWOOD',
    NewYork: 'NEW_YORK',
    SanFrancisco: 'SAN_FRANCISCO',
    JurassicPark: 'JURASSIC_PARK',
    AmityVillage: 'AMITY_VILLAGE',
    Waterworld: 'WATERWORLD',
    WizardingWorld: 'WIZARDING_WORLD',
    MinionPark: 'MINION_PARK',
    Other: 'OTHER'
} as const;

export type AttractionDetailAreaEnum = typeof AttractionDetailAreaEnum[keyof typeof AttractionDetailAreaEnum];

/**
 * 
 * @export
 * @interface AttractionDetailAllOfOperatingHours
 */
export interface AttractionDetailAllOfOperatingHours {
    /**
     * 
     * @type {string}
     * @memberof AttractionDetailAllOfOperatingHours
     */
    'open'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttractionDetailAllOfOperatingHours
     */
    'close'?: string;
}
/**
 * 
 * @export
 * @interface AuthResponse
 */
export interface AuthResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    'token'?: string;
    /**
     * 
     * @type {User}
     * @memberof AuthResponse
     */
    'user'?: User;
}
/**
 * 
 * @export
 * @interface CreateDatePlanItemRequest
 */
export interface CreateDatePlanItemRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateDatePlanItemRequest
     */
    'attractionId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateDatePlanItemRequest
     */
    'scheduledTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateDatePlanItemRequest
     */
    'estimatedDuration'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateDatePlanItemRequest
     */
    'notes'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateDatePlanItemRequest
     */
    'order': number;
}
/**
 * 
 * @export
 * @interface CreateDatePlanRequest
 */
export interface CreateDatePlanRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateDatePlanRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateDatePlanRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDatePlanRequest
     */
    'scheduledDate': string;
    /**
     * 
     * @type {Array<CreateDatePlanItemRequest>}
     * @memberof CreateDatePlanRequest
     */
    'items'?: Array<CreateDatePlanItemRequest>;
}
/**
 * 
 * @export
 * @interface DatePlan
 */
export interface DatePlan {
    /**
     * 
     * @type {number}
     * @memberof DatePlan
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DatePlan
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof DatePlan
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof DatePlan
     */
    'creatorId'?: number;
    /**
     * 
     * @type {number}
     * @memberof DatePlan
     */
    'sharedWithUserId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DatePlan
     */
    'scheduledDate'?: string;
    /**
     * 
     * @type {Array<DatePlanItem>}
     * @memberof DatePlan
     */
    'items'?: Array<DatePlanItem>;
    /**
     * 
     * @type {string}
     * @memberof DatePlan
     */
    'status'?: DatePlanStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof DatePlan
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DatePlan
     */
    'updatedAt'?: string;
}

export const DatePlanStatusEnum = {
    Draft: 'DRAFT',
    Shared: 'SHARED',
    Confirmed: 'CONFIRMED',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED'
} as const;

export type DatePlanStatusEnum = typeof DatePlanStatusEnum[keyof typeof DatePlanStatusEnum];

/**
 * 
 * @export
 * @interface DatePlanDetail
 */
export interface DatePlanDetail {
    /**
     * 
     * @type {number}
     * @memberof DatePlanDetail
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DatePlanDetail
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof DatePlanDetail
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof DatePlanDetail
     */
    'creatorId'?: number;
    /**
     * 
     * @type {number}
     * @memberof DatePlanDetail
     */
    'sharedWithUserId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DatePlanDetail
     */
    'scheduledDate'?: string;
    /**
     * 
     * @type {Array<DatePlanItem>}
     * @memberof DatePlanDetail
     */
    'items'?: Array<DatePlanItem>;
    /**
     * 
     * @type {string}
     * @memberof DatePlanDetail
     */
    'status'?: DatePlanDetailStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof DatePlanDetail
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DatePlanDetail
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {PublicProfile}
     * @memberof DatePlanDetail
     */
    'creator'?: PublicProfile;
    /**
     * 
     * @type {PublicProfile}
     * @memberof DatePlanDetail
     */
    'sharedWithUser'?: PublicProfile;
}

export const DatePlanDetailStatusEnum = {
    Draft: 'DRAFT',
    Shared: 'SHARED',
    Confirmed: 'CONFIRMED',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED'
} as const;

export type DatePlanDetailStatusEnum = typeof DatePlanDetailStatusEnum[keyof typeof DatePlanDetailStatusEnum];

/**
 * 
 * @export
 * @interface DatePlanItem
 */
export interface DatePlanItem {
    /**
     * 
     * @type {number}
     * @memberof DatePlanItem
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof DatePlanItem
     */
    'attractionId'?: number;
    /**
     * 
     * @type {Attraction}
     * @memberof DatePlanItem
     */
    'attraction'?: Attraction;
    /**
     * 
     * @type {string}
     * @memberof DatePlanItem
     */
    'scheduledTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof DatePlanItem
     */
    'estimatedDuration'?: number;
    /**
     * 
     * @type {string}
     * @memberof DatePlanItem
     */
    'notes'?: string;
    /**
     * 
     * @type {number}
     * @memberof DatePlanItem
     */
    'order'?: number;
}
/**
 * 
 * @export
 * @interface LikeRequest
 */
export interface LikeRequest {
    /**
     * 
     * @type {number}
     * @memberof LikeRequest
     */
    'targetUserId': number;
}
/**
 * 
 * @export
 * @interface LikeResponse
 */
export interface LikeResponse {
    /**
     * 
     * @type {boolean}
     * @memberof LikeResponse
     */
    'isMatch'?: boolean;
    /**
     * 
     * @type {Match}
     * @memberof LikeResponse
     */
    'match'?: Match;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Match
 */
export interface Match {
    /**
     * 
     * @type {number}
     * @memberof Match
     */
    'id'?: number;
    /**
     * 
     * @type {PublicProfile}
     * @memberof Match
     */
    'user1'?: PublicProfile;
    /**
     * 
     * @type {PublicProfile}
     * @memberof Match
     */
    'user2'?: PublicProfile;
    /**
     * 
     * @type {string}
     * @memberof Match
     */
    'matchedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Match
     */
    'lastMessageAt'?: string;
}
/**
 * 
 * @export
 * @interface MatchingCandidate
 */
export interface MatchingCandidate {
    /**
     * 
     * @type {PublicProfile}
     * @memberof MatchingCandidate
     */
    'profile'?: PublicProfile;
    /**
     * 
     * @type {number}
     * @memberof MatchingCandidate
     */
    'compatibility'?: number;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    'matchId'?: number;
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    'senderId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'sentAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'isRead'?: boolean;
}
/**
 * 
 * @export
 * @interface Profile
 */
export interface Profile {
    /**
     * 
     * @type {number}
     * @memberof Profile
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Profile
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'bio'?: string;
    /**
     * 
     * @type {number}
     * @memberof Profile
     */
    'height'?: number;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'occupation'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Profile
     */
    'hobbies'?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Profile
     */
    'favoriteAttractions'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'visitFrequency'?: ProfileVisitFrequencyEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof Profile
     */
    'preferredAreas'?: Array<ProfilePreferredAreasEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Profile
     */
    'profileImages'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Profile
     */
    'isVisible'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    'updatedAt'?: string;
}

export const ProfileVisitFrequencyEnum = {
    FirstTime: 'FIRST_TIME',
    Monthly: 'MONTHLY',
    Weekly: 'WEEKLY',
    Daily: 'DAILY'
} as const;

export type ProfileVisitFrequencyEnum = typeof ProfileVisitFrequencyEnum[keyof typeof ProfileVisitFrequencyEnum];
export const ProfilePreferredAreasEnum = {
    Hollywood: 'HOLLYWOOD',
    NewYork: 'NEW_YORK',
    SanFrancisco: 'SAN_FRANCISCO',
    JurassicPark: 'JURASSIC_PARK',
    AmityVillage: 'AMITY_VILLAGE',
    Waterworld: 'WATERWORLD',
    WizardingWorld: 'WIZARDING_WORLD',
    MinionPark: 'MINION_PARK',
    Other: 'OTHER'
} as const;

export type ProfilePreferredAreasEnum = typeof ProfilePreferredAreasEnum[keyof typeof ProfilePreferredAreasEnum];

/**
 * 
 * @export
 * @interface ProfileUpdateRequest
 */
export interface ProfileUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdateRequest
     */
    'bio'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProfileUpdateRequest
     */
    'height'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdateRequest
     */
    'occupation'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileUpdateRequest
     */
    'hobbies'?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ProfileUpdateRequest
     */
    'favoriteAttractions'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdateRequest
     */
    'visitFrequency'?: ProfileUpdateRequestVisitFrequencyEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileUpdateRequest
     */
    'preferredAreas'?: Array<ProfileUpdateRequestPreferredAreasEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileUpdateRequest
     */
    'profileImages'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileUpdateRequest
     */
    'isVisible'?: boolean;
}

export const ProfileUpdateRequestVisitFrequencyEnum = {
    FirstTime: 'FIRST_TIME',
    Monthly: 'MONTHLY',
    Weekly: 'WEEKLY',
    Daily: 'DAILY'
} as const;

export type ProfileUpdateRequestVisitFrequencyEnum = typeof ProfileUpdateRequestVisitFrequencyEnum[keyof typeof ProfileUpdateRequestVisitFrequencyEnum];
export const ProfileUpdateRequestPreferredAreasEnum = {
    Hollywood: 'HOLLYWOOD',
    NewYork: 'NEW_YORK',
    SanFrancisco: 'SAN_FRANCISCO',
    JurassicPark: 'JURASSIC_PARK',
    AmityVillage: 'AMITY_VILLAGE',
    Waterworld: 'WATERWORLD',
    WizardingWorld: 'WIZARDING_WORLD',
    MinionPark: 'MINION_PARK',
    Other: 'OTHER'
} as const;

export type ProfileUpdateRequestPreferredAreasEnum = typeof ProfileUpdateRequestPreferredAreasEnum[keyof typeof ProfileUpdateRequestPreferredAreasEnum];

/**
 * 
 * @export
 * @interface PublicProfile
 */
export interface PublicProfile {
    /**
     * 
     * @type {number}
     * @memberof PublicProfile
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PublicProfile
     */
    'nickname'?: string;
    /**
     * 
     * @type {number}
     * @memberof PublicProfile
     */
    'age'?: number;
    /**
     * 
     * @type {string}
     * @memberof PublicProfile
     */
    'bio'?: string;
    /**
     * 
     * @type {number}
     * @memberof PublicProfile
     */
    'height'?: number;
    /**
     * 
     * @type {string}
     * @memberof PublicProfile
     */
    'occupation'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PublicProfile
     */
    'hobbies'?: Array<string>;
    /**
     * 
     * @type {Array<Attraction>}
     * @memberof PublicProfile
     */
    'favoriteAttractions'?: Array<Attraction>;
    /**
     * 
     * @type {string}
     * @memberof PublicProfile
     */
    'visitFrequency'?: PublicProfileVisitFrequencyEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof PublicProfile
     */
    'preferredAreas'?: Array<PublicProfilePreferredAreasEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PublicProfile
     */
    'profileImages'?: Array<string>;
}

export const PublicProfileVisitFrequencyEnum = {
    FirstTime: 'FIRST_TIME',
    Monthly: 'MONTHLY',
    Weekly: 'WEEKLY',
    Daily: 'DAILY'
} as const;

export type PublicProfileVisitFrequencyEnum = typeof PublicProfileVisitFrequencyEnum[keyof typeof PublicProfileVisitFrequencyEnum];
export const PublicProfilePreferredAreasEnum = {
    Hollywood: 'HOLLYWOOD',
    NewYork: 'NEW_YORK',
    SanFrancisco: 'SAN_FRANCISCO',
    JurassicPark: 'JURASSIC_PARK',
    AmityVillage: 'AMITY_VILLAGE',
    Waterworld: 'WATERWORLD',
    WizardingWorld: 'WIZARDING_WORLD',
    MinionPark: 'MINION_PARK',
    Other: 'OTHER'
} as const;

export type PublicProfilePreferredAreasEnum = typeof PublicProfilePreferredAreasEnum[keyof typeof PublicProfilePreferredAreasEnum];

/**
 * 
 * @export
 * @interface SendMessageRequest
 */
export interface SendMessageRequest {
    /**
     * 
     * @type {number}
     * @memberof SendMessageRequest
     */
    'matchId': number;
    /**
     * 
     * @type {string}
     * @memberof SendMessageRequest
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface UpdateDatePlanRequest
 */
export interface UpdateDatePlanRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateDatePlanRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDatePlanRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDatePlanRequest
     */
    'scheduledDate'?: string;
    /**
     * 
     * @type {Array<CreateDatePlanItemRequest>}
     * @memberof UpdateDatePlanRequest
     */
    'items'?: Array<CreateDatePlanItemRequest>;
    /**
     * 
     * @type {string}
     * @memberof UpdateDatePlanRequest
     */
    'status'?: UpdateDatePlanRequestStatusEnum;
}

export const UpdateDatePlanRequestStatusEnum = {
    Draft: 'DRAFT',
    Shared: 'SHARED',
    Confirmed: 'CONFIRMED',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED'
} as const;

export type UpdateDatePlanRequestStatusEnum = typeof UpdateDatePlanRequestStatusEnum[keyof typeof UpdateDatePlanRequestStatusEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'birthDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'gender'?: UserGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt'?: string;
}

export const UserGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE',
    Other: 'OTHER'
} as const;

export type UserGenderEnum = typeof UserGenderEnum[keyof typeof UserGenderEnum];

/**
 * 
 * @export
 * @interface UserRegistrationRequest
 */
export interface UserRegistrationRequest {
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationRequest
     */
    'nickname': string;
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationRequest
     */
    'birthDate': string;
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationRequest
     */
    'gender': UserRegistrationRequestGenderEnum;
}

export const UserRegistrationRequestGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE',
    Other: 'OTHER'
} as const;

export type UserRegistrationRequestGenderEnum = typeof UserRegistrationRequestGenderEnum[keyof typeof UserRegistrationRequestGenderEnum];

/**
 * 
 * @export
 * @interface UserUpdateRequest
 */
export interface UserUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof UserUpdateRequest
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateRequest
     */
    'birthDate'?: string;
}

/**
 * AttractionsApi - axios parameter creator
 * @export
 */
export const AttractionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定したアトラクションの詳細情報を取得します
         * @summary アトラクション詳細取得
         * @param {number} attractionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAttractionsAttractionIdGet: async (attractionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attractionId' is not null or undefined
            assertParamExists('apiAttractionsAttractionIdGet', 'attractionId', attractionId)
            const localVarPath = `/api/attractions/{attractionId}`
                .replace(`{${"attractionId"}}`, encodeURIComponent(String(attractionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * USJのアトラクション一覧を取得します
         * @summary アトラクション一覧取得
         * @param {ApiAttractionsGetCategoryEnum} [category] 
         * @param {ApiAttractionsGetAreaEnum} [area] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAttractionsGet: async (category?: ApiAttractionsGetCategoryEnum, area?: ApiAttractionsGetAreaEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/attractions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (area !== undefined) {
                localVarQueryParameter['area'] = area;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttractionsApi - functional programming interface
 * @export
 */
export const AttractionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AttractionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定したアトラクションの詳細情報を取得します
         * @summary アトラクション詳細取得
         * @param {number} attractionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAttractionsAttractionIdGet(attractionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttractionDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAttractionsAttractionIdGet(attractionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttractionsApi.apiAttractionsAttractionIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * USJのアトラクション一覧を取得します
         * @summary アトラクション一覧取得
         * @param {ApiAttractionsGetCategoryEnum} [category] 
         * @param {ApiAttractionsGetAreaEnum} [area] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAttractionsGet(category?: ApiAttractionsGetCategoryEnum, area?: ApiAttractionsGetAreaEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Attraction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAttractionsGet(category, area, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttractionsApi.apiAttractionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AttractionsApi - factory interface
 * @export
 */
export const AttractionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AttractionsApiFp(configuration)
    return {
        /**
         * 指定したアトラクションの詳細情報を取得します
         * @summary アトラクション詳細取得
         * @param {number} attractionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAttractionsAttractionIdGet(attractionId: number, options?: RawAxiosRequestConfig): AxiosPromise<AttractionDetail> {
            return localVarFp.apiAttractionsAttractionIdGet(attractionId, options).then((request) => request(axios, basePath));
        },
        /**
         * USJのアトラクション一覧を取得します
         * @summary アトラクション一覧取得
         * @param {ApiAttractionsGetCategoryEnum} [category] 
         * @param {ApiAttractionsGetAreaEnum} [area] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAttractionsGet(category?: ApiAttractionsGetCategoryEnum, area?: ApiAttractionsGetAreaEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<Attraction>> {
            return localVarFp.apiAttractionsGet(category, area, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AttractionsApi - object-oriented interface
 * @export
 * @class AttractionsApi
 * @extends {BaseAPI}
 */
export class AttractionsApi extends BaseAPI {
    /**
     * 指定したアトラクションの詳細情報を取得します
     * @summary アトラクション詳細取得
     * @param {number} attractionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttractionsApi
     */
    public apiAttractionsAttractionIdGet(attractionId: number, options?: RawAxiosRequestConfig) {
        return AttractionsApiFp(this.configuration).apiAttractionsAttractionIdGet(attractionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * USJのアトラクション一覧を取得します
     * @summary アトラクション一覧取得
     * @param {ApiAttractionsGetCategoryEnum} [category] 
     * @param {ApiAttractionsGetAreaEnum} [area] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttractionsApi
     */
    public apiAttractionsGet(category?: ApiAttractionsGetCategoryEnum, area?: ApiAttractionsGetAreaEnum, options?: RawAxiosRequestConfig) {
        return AttractionsApiFp(this.configuration).apiAttractionsGet(category, area, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ApiAttractionsGetCategoryEnum = {
    Ride: 'RIDE',
    Show: 'SHOW',
    Restaurant: 'RESTAURANT',
    Shop: 'SHOP',
    Other: 'OTHER'
} as const;
export type ApiAttractionsGetCategoryEnum = typeof ApiAttractionsGetCategoryEnum[keyof typeof ApiAttractionsGetCategoryEnum];
/**
 * @export
 */
export const ApiAttractionsGetAreaEnum = {
    Hollywood: 'HOLLYWOOD',
    NewYork: 'NEW_YORK',
    SanFrancisco: 'SAN_FRANCISCO',
    JurassicPark: 'JURASSIC_PARK',
    AmityVillage: 'AMITY_VILLAGE',
    Waterworld: 'WATERWORLD',
    WizardingWorld: 'WIZARDING_WORLD',
    MinionPark: 'MINION_PARK',
    Other: 'OTHER'
} as const;
export type ApiAttractionsGetAreaEnum = typeof ApiAttractionsGetAreaEnum[keyof typeof ApiAttractionsGetAreaEnum];


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ユーザーログインを行います
         * @summary ログイン
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthLoginPost: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('apiAuthLoginPost', 'loginRequest', loginRequest)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザーログアウトを行います
         * @summary ログアウト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthLogoutPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新規ユーザーを登録します
         * @summary ユーザー登録
         * @param {UserRegistrationRequest} userRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthRegisterPost: async (userRegistrationRequest: UserRegistrationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRegistrationRequest' is not null or undefined
            assertParamExists('apiAuthRegisterPost', 'userRegistrationRequest', userRegistrationRequest)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRegistrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * ユーザーログインを行います
         * @summary ログイン
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthLoginPost(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.apiAuthLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ユーザーログアウトを行います
         * @summary ログアウト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthLogoutPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthLogoutPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.apiAuthLogoutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新規ユーザーを登録します
         * @summary ユーザー登録
         * @param {UserRegistrationRequest} userRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthRegisterPost(userRegistrationRequest: UserRegistrationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthRegisterPost(userRegistrationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.apiAuthRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * ユーザーログインを行います
         * @summary ログイン
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.apiAuthLoginPost(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ユーザーログアウトを行います
         * @summary ログアウト
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthLogoutPost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiAuthLogoutPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 新規ユーザーを登録します
         * @summary ユーザー登録
         * @param {UserRegistrationRequest} userRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthRegisterPost(userRegistrationRequest: UserRegistrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.apiAuthRegisterPost(userRegistrationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * ユーザーログインを行います
     * @summary ログイン
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiAuthLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthLoginPost(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザーログアウトを行います
     * @summary ログアウト
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiAuthLogoutPost(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthLogoutPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新規ユーザーを登録します
     * @summary ユーザー登録
     * @param {UserRegistrationRequest} userRegistrationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiAuthRegisterPost(userRegistrationRequest: UserRegistrationRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthRegisterPost(userRegistrationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MatchingApi - axios parameter creator
 * @export
 */
export const MatchingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 現在のユーザーに対するマッチング候補を取得します
         * @summary マッチング候補取得
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMatchingCandidatesGet: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/matching/candidates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザーにいいねを送信します
         * @summary いいね送信
         * @param {LikeRequest} likeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMatchingLikePost: async (likeRequest: LikeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'likeRequest' is not null or undefined
            assertParamExists('apiMatchingLikePost', 'likeRequest', likeRequest)
            const localVarPath = `/api/matching/like`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(likeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 成立したマッチの一覧を取得します
         * @summary マッチ一覧取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMatchingMatchesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/matching/matches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchingApi - functional programming interface
 * @export
 */
export const MatchingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MatchingApiAxiosParamCreator(configuration)
    return {
        /**
         * 現在のユーザーに対するマッチング候補を取得します
         * @summary マッチング候補取得
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMatchingCandidatesGet(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MatchingCandidate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMatchingCandidatesGet(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchingApi.apiMatchingCandidatesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定したユーザーにいいねを送信します
         * @summary いいね送信
         * @param {LikeRequest} likeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMatchingLikePost(likeRequest: LikeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LikeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMatchingLikePost(likeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchingApi.apiMatchingLikePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 成立したマッチの一覧を取得します
         * @summary マッチ一覧取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMatchingMatchesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Match>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMatchingMatchesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchingApi.apiMatchingMatchesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MatchingApi - factory interface
 * @export
 */
export const MatchingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MatchingApiFp(configuration)
    return {
        /**
         * 現在のユーザーに対するマッチング候補を取得します
         * @summary マッチング候補取得
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMatchingCandidatesGet(limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<MatchingCandidate>> {
            return localVarFp.apiMatchingCandidatesGet(limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定したユーザーにいいねを送信します
         * @summary いいね送信
         * @param {LikeRequest} likeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMatchingLikePost(likeRequest: LikeRequest, options?: RawAxiosRequestConfig): AxiosPromise<LikeResponse> {
            return localVarFp.apiMatchingLikePost(likeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 成立したマッチの一覧を取得します
         * @summary マッチ一覧取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMatchingMatchesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Match>> {
            return localVarFp.apiMatchingMatchesGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MatchingApi - object-oriented interface
 * @export
 * @class MatchingApi
 * @extends {BaseAPI}
 */
export class MatchingApi extends BaseAPI {
    /**
     * 現在のユーザーに対するマッチング候補を取得します
     * @summary マッチング候補取得
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchingApi
     */
    public apiMatchingCandidatesGet(limit?: number, options?: RawAxiosRequestConfig) {
        return MatchingApiFp(this.configuration).apiMatchingCandidatesGet(limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定したユーザーにいいねを送信します
     * @summary いいね送信
     * @param {LikeRequest} likeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchingApi
     */
    public apiMatchingLikePost(likeRequest: LikeRequest, options?: RawAxiosRequestConfig) {
        return MatchingApiFp(this.configuration).apiMatchingLikePost(likeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 成立したマッチの一覧を取得します
     * @summary マッチ一覧取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchingApi
     */
    public apiMatchingMatchesGet(options?: RawAxiosRequestConfig) {
        return MatchingApiFp(this.configuration).apiMatchingMatchesGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MessagesApi - axios parameter creator
 * @export
 */
export const MessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定したマッチのメッセージ一覧を取得します
         * @summary メッセージ一覧取得
         * @param {number} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMessagesGet: async (matchId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchId' is not null or undefined
            assertParamExists('apiMessagesGet', 'matchId', matchId)
            const localVarPath = `/api/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (matchId !== undefined) {
                localVarQueryParameter['matchId'] = matchId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したマッチにメッセージを送信します
         * @summary メッセージ送信
         * @param {SendMessageRequest} sendMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMessagesPost: async (sendMessageRequest: SendMessageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendMessageRequest' is not null or undefined
            assertParamExists('apiMessagesPost', 'sendMessageRequest', sendMessageRequest)
            const localVarPath = `/api/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定したマッチのメッセージ一覧を取得します
         * @summary メッセージ一覧取得
         * @param {number} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMessagesGet(matchId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Message>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMessagesGet(matchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.apiMessagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定したマッチにメッセージを送信します
         * @summary メッセージ送信
         * @param {SendMessageRequest} sendMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMessagesPost(sendMessageRequest: SendMessageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMessagesPost(sendMessageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.apiMessagesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagesApiFp(configuration)
    return {
        /**
         * 指定したマッチのメッセージ一覧を取得します
         * @summary メッセージ一覧取得
         * @param {number} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMessagesGet(matchId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Message>> {
            return localVarFp.apiMessagesGet(matchId, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定したマッチにメッセージを送信します
         * @summary メッセージ送信
         * @param {SendMessageRequest} sendMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMessagesPost(sendMessageRequest: SendMessageRequest, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.apiMessagesPost(sendMessageRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI {
    /**
     * 指定したマッチのメッセージ一覧を取得します
     * @summary メッセージ一覧取得
     * @param {number} matchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public apiMessagesGet(matchId: number, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).apiMessagesGet(matchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定したマッチにメッセージを送信します
     * @summary メッセージ送信
     * @param {SendMessageRequest} sendMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public apiMessagesPost(sendMessageRequest: SendMessageRequest, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).apiMessagesPost(sendMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlansApi - axios parameter creator
 * @export
 */
export const PlansApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 作成したデートプランの一覧を取得します
         * @summary デートプラン一覧取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPlansGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したデートプランを削除します
         * @summary デートプラン削除
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPlansPlanIdDelete: async (planId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('apiPlansPlanIdDelete', 'planId', planId)
            const localVarPath = `/api/plans/{planId}`
                .replace(`{${"planId"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したデートプランの詳細を取得します
         * @summary デートプラン詳細取得
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPlansPlanIdGet: async (planId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('apiPlansPlanIdGet', 'planId', planId)
            const localVarPath = `/api/plans/{planId}`
                .replace(`{${"planId"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したデートプランを更新します
         * @summary デートプラン更新
         * @param {number} planId 
         * @param {UpdateDatePlanRequest} updateDatePlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPlansPlanIdPut: async (planId: number, updateDatePlanRequest: UpdateDatePlanRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('apiPlansPlanIdPut', 'planId', planId)
            // verify required parameter 'updateDatePlanRequest' is not null or undefined
            assertParamExists('apiPlansPlanIdPut', 'updateDatePlanRequest', updateDatePlanRequest)
            const localVarPath = `/api/plans/{planId}`
                .replace(`{${"planId"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDatePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 新しいデートプランを作成します
         * @summary デートプラン作成
         * @param {CreateDatePlanRequest} createDatePlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPlansPost: async (createDatePlanRequest: CreateDatePlanRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDatePlanRequest' is not null or undefined
            assertParamExists('apiPlansPost', 'createDatePlanRequest', createDatePlanRequest)
            const localVarPath = `/api/plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDatePlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlansApi - functional programming interface
 * @export
 */
export const PlansApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlansApiAxiosParamCreator(configuration)
    return {
        /**
         * 作成したデートプランの一覧を取得します
         * @summary デートプラン一覧取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPlansGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DatePlan>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPlansGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlansApi.apiPlansGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定したデートプランを削除します
         * @summary デートプラン削除
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPlansPlanIdDelete(planId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPlansPlanIdDelete(planId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlansApi.apiPlansPlanIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定したデートプランの詳細を取得します
         * @summary デートプラン詳細取得
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPlansPlanIdGet(planId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatePlanDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPlansPlanIdGet(planId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlansApi.apiPlansPlanIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定したデートプランを更新します
         * @summary デートプラン更新
         * @param {number} planId 
         * @param {UpdateDatePlanRequest} updateDatePlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPlansPlanIdPut(planId: number, updateDatePlanRequest: UpdateDatePlanRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPlansPlanIdPut(planId, updateDatePlanRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlansApi.apiPlansPlanIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 新しいデートプランを作成します
         * @summary デートプラン作成
         * @param {CreateDatePlanRequest} createDatePlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPlansPost(createDatePlanRequest: CreateDatePlanRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatePlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPlansPost(createDatePlanRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlansApi.apiPlansPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlansApi - factory interface
 * @export
 */
export const PlansApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlansApiFp(configuration)
    return {
        /**
         * 作成したデートプランの一覧を取得します
         * @summary デートプラン一覧取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPlansGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<DatePlan>> {
            return localVarFp.apiPlansGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 指定したデートプランを削除します
         * @summary デートプラン削除
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPlansPlanIdDelete(planId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiPlansPlanIdDelete(planId, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定したデートプランの詳細を取得します
         * @summary デートプラン詳細取得
         * @param {number} planId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPlansPlanIdGet(planId: number, options?: RawAxiosRequestConfig): AxiosPromise<DatePlanDetail> {
            return localVarFp.apiPlansPlanIdGet(planId, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定したデートプランを更新します
         * @summary デートプラン更新
         * @param {number} planId 
         * @param {UpdateDatePlanRequest} updateDatePlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPlansPlanIdPut(planId: number, updateDatePlanRequest: UpdateDatePlanRequest, options?: RawAxiosRequestConfig): AxiosPromise<DatePlan> {
            return localVarFp.apiPlansPlanIdPut(planId, updateDatePlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 新しいデートプランを作成します
         * @summary デートプラン作成
         * @param {CreateDatePlanRequest} createDatePlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPlansPost(createDatePlanRequest: CreateDatePlanRequest, options?: RawAxiosRequestConfig): AxiosPromise<DatePlan> {
            return localVarFp.apiPlansPost(createDatePlanRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlansApi - object-oriented interface
 * @export
 * @class PlansApi
 * @extends {BaseAPI}
 */
export class PlansApi extends BaseAPI {
    /**
     * 作成したデートプランの一覧を取得します
     * @summary デートプラン一覧取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlansApi
     */
    public apiPlansGet(options?: RawAxiosRequestConfig) {
        return PlansApiFp(this.configuration).apiPlansGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定したデートプランを削除します
     * @summary デートプラン削除
     * @param {number} planId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlansApi
     */
    public apiPlansPlanIdDelete(planId: number, options?: RawAxiosRequestConfig) {
        return PlansApiFp(this.configuration).apiPlansPlanIdDelete(planId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定したデートプランの詳細を取得します
     * @summary デートプラン詳細取得
     * @param {number} planId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlansApi
     */
    public apiPlansPlanIdGet(planId: number, options?: RawAxiosRequestConfig) {
        return PlansApiFp(this.configuration).apiPlansPlanIdGet(planId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定したデートプランを更新します
     * @summary デートプラン更新
     * @param {number} planId 
     * @param {UpdateDatePlanRequest} updateDatePlanRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlansApi
     */
    public apiPlansPlanIdPut(planId: number, updateDatePlanRequest: UpdateDatePlanRequest, options?: RawAxiosRequestConfig) {
        return PlansApiFp(this.configuration).apiPlansPlanIdPut(planId, updateDatePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 新しいデートプランを作成します
     * @summary デートプラン作成
     * @param {CreateDatePlanRequest} createDatePlanRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlansApi
     */
    public apiPlansPost(createDatePlanRequest: CreateDatePlanRequest, options?: RawAxiosRequestConfig) {
        return PlansApiFp(this.configuration).apiPlansPost(createDatePlanRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfilesApi - axios parameter creator
 * @export
 */
export const ProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 認証されたユーザーの詳細プロフィールを取得します
         * @summary 自分のプロフィール取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProfilesMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/profiles/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 認証されたユーザーのプロフィールを更新します
         * @summary プロフィール更新
         * @param {ProfileUpdateRequest} profileUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProfilesMePut: async (profileUpdateRequest: ProfileUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileUpdateRequest' is not null or undefined
            assertParamExists('apiProfilesMePut', 'profileUpdateRequest', profileUpdateRequest)
            const localVarPath = `/api/profiles/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定したユーザーの公開プロフィールを取得します
         * @summary 他ユーザーのプロフィール取得
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProfilesUserIdGet: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiProfilesUserIdGet', 'userId', userId)
            const localVarPath = `/api/profiles/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfilesApi - functional programming interface
 * @export
 */
export const ProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 認証されたユーザーの詳細プロフィールを取得します
         * @summary 自分のプロフィール取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiProfilesMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiProfilesMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.apiProfilesMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 認証されたユーザーのプロフィールを更新します
         * @summary プロフィール更新
         * @param {ProfileUpdateRequest} profileUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiProfilesMePut(profileUpdateRequest: ProfileUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiProfilesMePut(profileUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.apiProfilesMePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 指定したユーザーの公開プロフィールを取得します
         * @summary 他ユーザーのプロフィール取得
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiProfilesUserIdGet(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiProfilesUserIdGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.apiProfilesUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfilesApi - factory interface
 * @export
 */
export const ProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfilesApiFp(configuration)
    return {
        /**
         * 認証されたユーザーの詳細プロフィールを取得します
         * @summary 自分のプロフィール取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProfilesMeGet(options?: RawAxiosRequestConfig): AxiosPromise<Profile> {
            return localVarFp.apiProfilesMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 認証されたユーザーのプロフィールを更新します
         * @summary プロフィール更新
         * @param {ProfileUpdateRequest} profileUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProfilesMePut(profileUpdateRequest: ProfileUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Profile> {
            return localVarFp.apiProfilesMePut(profileUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定したユーザーの公開プロフィールを取得します
         * @summary 他ユーザーのプロフィール取得
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProfilesUserIdGet(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<PublicProfile> {
            return localVarFp.apiProfilesUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfilesApi - object-oriented interface
 * @export
 * @class ProfilesApi
 * @extends {BaseAPI}
 */
export class ProfilesApi extends BaseAPI {
    /**
     * 認証されたユーザーの詳細プロフィールを取得します
     * @summary 自分のプロフィール取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public apiProfilesMeGet(options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).apiProfilesMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 認証されたユーザーのプロフィールを更新します
     * @summary プロフィール更新
     * @param {ProfileUpdateRequest} profileUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public apiProfilesMePut(profileUpdateRequest: ProfileUpdateRequest, options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).apiProfilesMePut(profileUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定したユーザーの公開プロフィールを取得します
     * @summary 他ユーザーのプロフィール取得
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public apiProfilesUserIdGet(userId: number, options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).apiProfilesUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 認証されたユーザーの情報を取得します
         * @summary 現在のユーザー情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 認証されたユーザーの基本情報を更新します
         * @summary ユーザー情報更新
         * @param {UserUpdateRequest} userUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersMePut: async (userUpdateRequest: UserUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUpdateRequest' is not null or undefined
            assertParamExists('apiUsersMePut', 'userUpdateRequest', userUpdateRequest)
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 認証されたユーザーの情報を取得します
         * @summary 現在のユーザー情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 認証されたユーザーの基本情報を更新します
         * @summary ユーザー情報更新
         * @param {UserUpdateRequest} userUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersMePut(userUpdateRequest: UserUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersMePut(userUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersMePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 認証されたユーザーの情報を取得します
         * @summary 現在のユーザー情報取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersMeGet(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.apiUsersMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 認証されたユーザーの基本情報を更新します
         * @summary ユーザー情報更新
         * @param {UserUpdateRequest} userUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersMePut(userUpdateRequest: UserUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.apiUsersMePut(userUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 認証されたユーザーの情報を取得します
     * @summary 現在のユーザー情報取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersMeGet(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 認証されたユーザーの基本情報を更新します
     * @summary ユーザー情報更新
     * @param {UserUpdateRequest} userUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersMePut(userUpdateRequest: UserUpdateRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersMePut(userUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



